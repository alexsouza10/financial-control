<template>
  <v-dialog
    :model-value="modelValue"
    @update:model-value="$emit('update:modelValue', $event)"
    persistent
    max-width="500"
  >
    <v-card class="pa-6 elevation-3 rounded-xl">
      <v-card-title class="text-h6 font-weight-bold pb-2">{{
        title
      }}</v-card-title>

      <v-card-text class="pb-0">
        <v-form ref="form" @submit.prevent="save">
          <v-text-field
            v-if="isSalaryEditMode"
            v-model.number="internalValue"
            :label="label"
            type="number"
            :min="min"
            :suffix="suffix"
            variant="outlined"
            density="comfortable"
            :rules="[valueRules.required, valueRules.minZero]"
            hide-details="auto"
            class="mb-4"
          />

          <template v-else>
            <v-select
              v-model="editedExpense.category"
              :items="categories"
              label="Categoria"
              variant="outlined"
              density="comfortable"
              hide-details="auto"
              class="mb-4"
              required
            />
            <v-select
              v-model="editedExpense.paymentMethod"
              :items="paymentMethods"
              label="Método de Pagamento"
              variant="outlined"
              density="comfortable"
              hide-details="auto"
              class="mb-4"
              required
            />
            <v-text-field
              v-if="editedExpense.paymentMethod === 'Cartão de Crédito'"
              v-model.number="editedExpense.installments"
              label="Parcelas"
              type="number"
              min="1"
              variant="outlined"
              density="comfortable"
              hide-details="auto"
              class="mb-4"
            />
            <v-select
              v-if="editedExpense.paymentMethod === 'Cartão de Crédito'"
              v-model="editedExpense.card"
              :items="cardOptions"
              label="Cartão"
              variant="outlined"
              density="comfortable"
              hide-details="auto"
              class="mb-4"
            />
            <v-text-field
              v-model.number="editedExpense.value"
              label="Valor"
              type="number"
              suffix="R$"
              variant="outlined"
              density="comfortable"
              :rules="[valueRules.required, valueRules.minZero]"
              hide-details="auto"
              class="mb-4"
            />
            <DatePickerField
              v-model="editedExpense.date"
              label="Data do Gasto"
              class="mb-2"
              :rules="[valueRules.required]"
            />
          </template>
        </v-form>
      </v-card-text>

      <v-card-actions class="pt-4">
        <v-spacer />
        <v-btn variant="text" color="secondary" @click="cancel">Cancelar</v-btn>
        <v-btn variant="flat" :color="confirmColor" @click="save">Salvar</v-btn>
      </v-card-actions>
    </v-card>
  </v-dialog>

  <v-snackbar
    v-model="snackbar.show"
    :color="snackbar.color"
    :timeout="snackbar.timeout"
  >
    {{ snackbar.message }}
    <template #actions>
      <v-btn text @click="snackbar.show = false"> Fechar </v-btn>
    </template>
  </v-snackbar>
</template>

<script setup lang="ts">
import { ref, watch, computed } from "vue";
import { useTheme } from "vuetify";
import { parseISO, format, addMonths } from "date-fns";
import DatePickerField from "~/components/atoms/DatePickerField.vue";
import { useExpensesStore } from "~/stores/expenses";
import type { Expense } from "~/types/expense";
import type { VForm } from "vuetify/components";
import { AxiosError } from "axios";

interface Props {
  modelValue: boolean;
  value?: number | null;
  expense?: Expense | null;
  title?: string;
  label?: string;
  min?: number;
  suffix?: string;
  confirmColor?: string;
}

const props = withDefaults(defineProps<Props>(), {
  title: "Editar",
  value: null,
  expense: null,
  label: "Valor",
  min: 0,
  suffix: "",
  confirmColor: "primary",
});

const emit = defineEmits<{
  (e: "update:modelValue", value: boolean): void;
  (e: "update:expense", value: Expense): void;
  (e: "update:value", value: number): void;
}>();

const expensesStore = useExpensesStore();

const form = ref<VForm | null>(null);
const editedExpense = ref<Expense>({} as Expense);
const internalValue = ref<number>(0);
const isSalaryEditMode = computed(
  () =>
    props.value !== undefined && props.value !== null && props.expense === null
);

const categories = [
  "Alimentação",
  "Transporte",
  "Saúde",
  "Lazer",
  "Contas",
  "Outros",
];
const paymentMethods = ["Cartão de Crédito", "Débito", "Dinheiro", "Pix"];
const cardOptions = ["Nubank", "Inter", "Neon", "PicPay", "Outro"];

const valueRules = {
  required: (v: any) =>
    (v !== null && v !== undefined && String(v).trim() !== "") ||
    "Campo obrigatório.",
  minZero: (v: number) => v >= 0 || "O valor não pode ser negativo.",
  minOneInstallment: (v: number) => v >= 1 || "Deve ter ao menos 1 parcela",
};

const theme = useTheme();

const snackbar = ref({
  show: false,
  message: "",
  color: "",
  timeout: 3000,
});

function loadDataForEditing() {
  if (isSalaryEditMode.value) {
    internalValue.value = props.value !== null ? props.value : 0;
  } else if (props.expense) {
    editedExpense.value = { ...props.expense };
    try {
      const date = parseISO(editedExpense.value.date);
      if (!isNaN(date.getTime())) {
        editedExpense.value.date = format(date, "yyyy-MM-dd");
      }
    } catch {
      editedExpense.value.date = "";
    }
  } else {
    editedExpense.value = {} as Expense;
    internalValue.value = 0;
  }
  form.value?.resetValidation();
}

watch(
  () => props.modelValue,
  (val) => val && loadDataForEditing()
);
watch(
  () => props.expense,
  (val) => !props.modelValue && loadDataForEditing()
);
watch(
  () => props.value,
  (val) => !props.modelValue && loadDataForEditing()
);

watch(
  () => editedExpense.value.paymentMethod,
  (newMethod) => {
    if (newMethod !== "Cartão de Crédito") {
      editedExpense.value.installments = 1;
      editedExpense.value.card = "";
      form.value?.resetValidation();
    }
  }
);

function cancel() {
  emit("update:modelValue", false);
}

async function save() {
  if (!form.value) return;

  const { valid } = await form.value.validate();

  if (!valid) {
    snackbar.value = {
      show: true,
      message: "Por favor, preencha todos os campos corretamente.",
      color: "warning",
      timeout: 3000,
    };
    return;
  }

  try {
    if (isSalaryEditMode.value) {
      emit("update:value", internalValue.value);
    } else if (editedExpense.value) {
      const originalExpenseId = props.expense?.id;
      const totalValue = editedExpense.value.value;
      const installmentsCount = editedExpense.value.installments;
      const initialDate = parseISO(editedExpense.value.date);

      if (installmentsCount > 1) {
        const expensesToRegister: Expense[] = [];
        const installmentValue = totalValue / installmentsCount;

        for (let i = 0; i < installmentsCount; i++) {
          const currentInstallmentDate = addMonths(initialDate, i);
          const formattedDate = format(currentInstallmentDate, "yyyy-MM-dd");

          expensesToRegister.push({
            ...editedExpense.value,
            id: undefined,
            value: installmentValue,
            installments: 1,
            date: `${formattedDate}T00:00:00.000Z`,
          });
        }

        if (originalExpenseId) {
          await expensesStore.deleteExpense(originalExpenseId);
        }

        await Promise.all(
          expensesToRegister.map((expense) => expensesStore.addExpense(expense))
        );

        snackbar.value = {
          show: true,
          message: "Gastos parcelados atualizados com sucesso!",
          color: "success",
          timeout: 3000,
        };
      } else {
        try {
          const localDate = new Date(editedExpense.value.date + "T00:00:00");
          const utcDate = new Date(
            Date.UTC(
              localDate.getFullYear(),
              localDate.getMonth(),
              localDate.getDate()
            )
          );
          editedExpense.value.date = utcDate.toISOString();
        } catch {
          editedExpense.value.date = "";
        }

        if (originalExpenseId) {
          await expensesStore.updateExpense(originalExpenseId, {
            category: editedExpense.value.category,
            paymentMethod: editedExpense.value.paymentMethod,
            card: editedExpense.value.card,
            installments: editedExpense.value.installments,
            value: editedExpense.value.value,
            date: editedExpense.value.date,
          });
          snackbar.value = {
            show: true,
            message: "Gasto atualizado com sucesso!",
            color: "success",
            timeout: 3000,
          };
        } else {
          await expensesStore.addExpense(editedExpense.value);
          snackbar.value = {
            show: true,
            message: "Gasto adicionado com sucesso!",
            color: "success",
            timeout: 3000,
          };
        }
      }
    }
    emit("update:modelValue", false);
    await expensesStore.fetchExpenses();
  } catch (error: unknown) {
    let errorMessage = "Erro ao salvar despesa. Verifique o console.";
    if (error instanceof AxiosError) {
      console.error(
        "Erro Axios ao salvar despesa:",
        error.response?.data || error.message
      );
      if (error.response?.data?.message) {
        errorMessage = `Erro: ${error.response.data.message}`;
      } else if (error.response?.status) {
        errorMessage = `Erro ${error.response.status}: ${error.message}`;
      }
    } else {
      console.error("Erro inesperado ao salvar despesa:", error);
    }

    snackbar.value = {
      show: true,
      message: errorMessage,
      color: "error",
      timeout: 5000,
    };
  }
}
</script>

<style scoped></style>
